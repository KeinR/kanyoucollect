


User does not actually know where their ships are exactly.
They are fed "reports" that each fleet sends in, which includes encounters
and whatnot, which happen as often as the user wants.
Radio can be intercepted, but is cheaper and faster and reliable.
Plane cannot be intercepted, but can be ex. shot down or crash or whatever.



Each user has a group of ships.
These include destroyers, cruisers, battleships, carriers, and subs.
Destroyers are +subs +speed +evasion +torpedoes (VERY speedy)
cruisers are beefy subs, with also +AA and less evasion.
battleships have no torpedos, but high firepower and range. Very low AA.
Carriers have planes, and thus high ACV and range and LOS. But, no firepower and low armor.
Subs have very low armor and only fire a few torpedoes, but are invulnerable to battleships and carriers (ASSASINS!)
Transports carry troops for land invasions. They have the speed of cruisers, but the armor of destroyers and no weapons.

Night battles:
Destroyes and cruisers get damage buffs, range is reduced so battleships are actually debuffed.
Carriers cannot launch planes, so they're sitting ducks.
Subs are invulnerable.
Only thing is, LOS is low, so it's hard to start a night battle unless one has already been going on.

Planes have high range, and deplate due to AA or enemy ACV.
There is a percentage chance of intercepting communications the closer you are to an enemy fleet.
There is also a small chance that you break the enemy codes. Also, a high chance of finding them if you capture an enemy ship.

Ships have fuel and ammo requirements, and if depleted, they are as good as dead.
Perhaps later have a tanker fleet that can restore fuel, but no. Don't do that.

Can only capture if enemy fleet surrenders.


Everything happens in real time, so the time that it takes you to fill out orders matters.
Orders are given in a very english like way, ex:
"Do not engage"
"If enemy spotted attack"
"Encrypt communications"
"Full speed"
"Half speed"
"Radio silence for five minutes"
"Capture port Guam"
"Bombard port Guam"
"Send Nagato and Saratoga to fleet 4"
"Create new fleet 8 with Mutsuki and Fubuki"
"Fleet 8:...[new orders for that fleet since they also receive the communication]"

Command flow:

- Get ships
- Organize into logical fleets so that they're easier to command
	- Each fleet can have formations that do different things, like
	protecting cruisers, or focusing on AA
- Give fleet orders
	- Go to location
	- Speed; at a certain point, higher speeds lead to lower fuel efficiency.
	- Return to port when needed; if the commander forgets, the fleet will automatically return to
	the closest port if low on fuel. They'll send a report before doing so.
	- Do not engage; avoid fighting with the enemy at all costs.
	- Radio silence; do not send reports back for a certain time period
	- Encrypt; only send encrypted messages. This will result in the enemy needing to break the codes first, but
	messages will take longer to transmit, and have a higher chance of failure on receipt (because they're encrypted,
	one error results in the whole thing needing to be re-sent, unless it's a simple ceaser cipher, in which case... Why???)
	- Formation; will determine combat ability, etc. For example, spreading out
	- Sending out patrol planes; will make fleet more visible, but in turn increase LOS
	- Lights out; Hunker down during nighttime to avoid being spotted. Reduces speed significantly.
	- Engage on sight; Do not ask before pursuing an engagement.
	- Capture; capture port
		- Loose crew when capturing port
	- Bombard; bombard port
	- (repair is done automatically if at a port)
        - Report on surroundings
- Fleet responds with status
	- Enemy spotted (with coordinates)
		- Attack
		- Retreat
		- Steady (default)
	- Low on fuel
		- Return to nearest port
	- Current coordinates
	- Direction, speed, ships in fleet, damage report, crew report
	- Supply report (influences morale)
	- Morale (lower values and smaller fleet sizes increase chance of desertion or surrender)







Tech needed:
- A string processor for commands
- Server / client model
	- Server sends out reports to client
	- Client sends orders to server
		- Each order has a target fleet
	- All data that can be is stored on the server, to prevent cheating.... Lmao useless.
		- Well also, it will increase data encapsulation, since they're all sharing the same state.
	- 
- Sockets for real time communication between client and server ( this is a multiplayer after all )
- One client decides to host server... Well of course, never mind. Have the server be a separate application.
- 




- NOTE ON NETWORKING: Will need to have the filesize in the header
in case the data must be sent in multible goes, so the client/server knows
to wait for more.

Client modules:
- PURPOSE
    - To interface with the server.
    - The client does not actually do any real computation,
    that all happens server side
- Networking
    - Sending and recieving data from the server
    + int connect(state, const char *ip, const char *port)
        - connect to a server
        - returns error
            - no error
            - failed to connect (connection)
            - invalid IP
            - invalid port (could not bind, in use, etc...)
    + int send(state, void *data, int dataSize)
        - Send data to connected server
        - Data should be in host byte order
        - Will send ALL the data, even if not everything is sent in
        one go
        - return error
            - disconnected/no connection/etc.
    + int receive(state, void *buffer, int bufferSize)
        - Receive data from server
        - Data is in host byte order
        - return error = 0, otherwise number of bytes written
            - No connection/disconnected
    + int tranDispatch(state)
        - Every call, calls receive. If got data, then
        parses header. Depending on the header, calls a callback (nethandle),
        which is of the form void net_hande_XXXX(state, void *data, int dataLen):
            - net_handle_report()
- User input
    - Obtaining the orders from the user in a timely fashion
    - send() is used to send order data
    - Send orders automatically inside certain folders 
        - The name of the file is parsed as a unix timestamp for when to send the order,
        thatis, if it is recognized as a integer
        - Does not send if it is open inside of another program
        - Moves to "sent" folder after sending
    + int getInput(const char *dir, const char *extRestrict, char *output, int outputLen)
        - Get the next file (THE FULL ABSOLUTE PATH) in dir that is ready to send (including based on timestamp)
        - Is not recursive
        - Returns NULL if there's nothing there.
        - Will ignore files not ending in `extRestrict`. Can set to NULL
        to disable this.
            - Note that the 
        - Return error
            - Buffer overflow; the absolute path overflows the given buffer
    + int getOrderReady(const char *filepath, int extRestrictLen)
        - Get if the order is ready. In this case, that means if the timestamp (which isn't
        required) has passed. Takes a substring not including the end extRestrict length, extRestrictLen.
        It doesn't need the string itself for obvious reasons.
    + int makeOrderHeader(state, const char *path, void *buffer, int bufferSize)
        - Write an order header based on file attributes and state information (it's not much...)
    + int readFile(const char *path, void *buffer, int bufferSize)
        - Read a file entirely into the given buffer
        - Reurn error
            - Overflow; file larger than buffer

- User output
    + void net_handle_report(state, void *data, int dataLen)
        - Called when a report comes in
        - Calls sendReport
    + int sendReport(const char *dir, int maxSize, header, void *data, int dataLen)
        - Generic, writes a report (data) based on the header to a file in `dir`
        - Return error
            - I/O error (file something)
            - Bad header
        - Checks the total size of files in directory. Deletes older files if the bytes
        exceeds `maxSize` to prevent destructive client DDoS

- Map
    - Queried from the server whenever it feels like
    - Special header for the request, of course
    - Writes the map in ASCII and image form for the user to view
    - Perhaps there are modes where there is no map

Server modules:
- Networking
    - Sending and receiving data from the client
    + int init(state, const char *port, int maxConnections)
        - Initialize the networking, start listening on port
        - will spawn a thread and start acceping connections, however will
        stay below maxConnections
    + int listen(state)
        - Start acceding connections
    + int ignore(state)
        - Ignore new connections
    + int accept(state, int *id)
        - Accepts a new connection
        - id -> the internal id referencing the connection
    + int alive(state, int id)
        - Checks if the connection is still alive
    + int disconnect(state, int id)
        - Disconnect the given id
    + int send(state, int id, const void *data, int dataSize)
        - Send data to connection id
        - Return error
            - Invalid connection
            - Disconnected


- Map generation
    - A pretty map is generated and written using stb_image that shows
    coordinates and where stuff is.
    - There is an ASCII version, perhaps less pretty
    - The client is responsible for rendering the image version, server
    provides raw map data
    - Generate a few blobs for islands, 3-5. Of those blobs, designage a few as bases.
    - Mainland can be sometimes generated, no more than 2.
    - Home bases for each faction are located as far away from each other as possible.
    - To ease some things calculation wise, each map is designated into cells that are the smallest area
    that the player can reference
    - Each cell is... wait I lost my train of thought hold on

- Language processing
    - Processing orders sent in by players
    - Actions...
        + int order_radioSilence(state, int value)
        + int order_bombard(state, int value)
        + int order_speed(state, int value)
        + int order_formation(state, int value)
        + int order_fleetName(state, int fleet, const char *name)
        + int order_shipName(state, int ship, const char *name)
        + int order_capture(state, int value)
        + int order_lights(state, int value)
        + int order_engage(state, int value)
    - Notice how they are all the same type. Taking advange of this?





Language design:

Nouns -> select object
    - "Fleet X"
    - "Port X"
    - Some nouns have a required/optional specifier, such as the fleet or port number
Adjetives narrow searches
    - "Enemy fleet X"
    - There are always defaults
Verbs perform actions with those selected nouns
    - "Enemy fleet 3 attack"
    - "Attack enemy fleet 3"
Adverbs perhaps not as useful to parse

When processing command string (and there's one per line btw):
- Create state object. This is a branching object.
- Encounter next word;
    - find closets match
    - if adjetive
        - Filter by "tag"
    - if noun
        - selct the group pertaining to the noun. That group should
        have a "tree" selection with nouns
        - some nouns require qualifiers, like "fleet 4" or "base five"
    - if AND
        - run this again, but the context noun is preserved, although
        it can change, "fleet 3 attack enemy fleet 2 and fleet 1"
    - if newline is encountered, continue if the sentence logically hasn't ended,
    ex: "fleet 4 report
    surroundings"
        - ACTUALLY, NO, all commands must be one line. For my sanity. For now.
        Perhaps if I drink some coffee...





Structures:

client side:

connection {
    int socketfd;
    char *ip;
    char *port;
    // Will never transmit more than this, ever, or "should not" (TM)
    char buffer[1028];
}

map {
    // Is null if no map
    char *ascii;
}

state {
    struct connection c;
    // The map, if querieid from server
    struct map map;
    // The name that the player presents to the server and other players
    char *playerName;
}



Server side:

buffer {
    int len;
    unsigned char *data;
}

connection {
    int socketfd;
    char ip[16];
    char port[8];
    char buffer[1028];
    bool valid;
}

typedef int shiptype;

// Ship type defs
#define SS 0
#define DD 1
#define CL 2
#define BB 3
#define CA 4
#define TR 5
// Aircraft
// I know, it's a little weird classifying it as a ship
// but it can interact with other ships, and whatever.
// So yah.
#define AI 6

typedef int speedtype;

// Speed defs
#define STOP 0 
#define SLOW 1
#define NORMAL 2
#define FAST 3
#define FASTEST 4

// Formation defs
#define LINE 0
#define DIAMOND 1
#define 

ship {
    shiptype type;
    double health;
    int fleet;
    char name[32];
    double fuel;
    // Note that cannot be replenished, which means
    // that you should be careful with how many times you
    // take a port
    // Decreases ship stats the lower it is
    int crew;
}

fleet {
    // -1 will mark the end of the array
    int ships[32];
    char name[32];
    double x;
    double y;

    // Target location, where it is going
    double tx;
    double ty;

    // How fast
    speedtype speed;
    // False for radio silence
    bool radio;
    // Formation
    int formation

    // Only relevent if in a port
    bool bombarding;
}

port {
    double x;
    double y;
    char name[32];
    // Index of player, or -1 for none
    int owner;
    // Land defense resistance, must be <= zero for capture.
    double resistance;
}

player {
    connection c;
    // This can vary if ex. one player gets to start with more ships.
    int numShips;
    ship ships[16];
}

// Each node represents a different point of interest.
typedef unsigned char nodetype;

// Defs for map data
#define OCEAN 0
#define LAND 1
// Multilbe defs for the port number
#define PORT 2...17
// Perhaps more accurate...
// (if port 1 is indexed as zero)
#define PORT(n) (n+1+LAND)
// This allows for directly indexing the ports
// from the map
// Otherwise, the client would have no way
// of knowing the names of the ports
// (unless we also sent them that information
// seperately in the form of coordinates, but that
// is just annoying)

map {
    nodetype *map;
    int w;
    int h;
}

state {
    // Hard limit on the number of connections
    player players[16];
    port ports[16];
    map m;
}

































The prefix will be "kyk"
kyks for server
kykc for client



